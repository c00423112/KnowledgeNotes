### JVM内存区域

**虚拟机栈**: 方法执行时的内存模型，线程私有，生命周期与线程相同，每个方法被执行同时会创建线程栈，主要保存执行方法的局部变量表，操作数栈、动态链接和方法的返回地址等信息，方法执行入栈，方法执行完出栈，不需要GC。

**本地方法栈**: 与虚拟机栈功能相似，主要区别是虚拟机栈为虚拟机执行Java服务，而本地方法栈为虚拟机执行本地方法时服务，这部分区域也不需要GC。

**程序计数器**:线程独有，可看作当前线程执行的字节码行号指示器。

**本地内存**: 线程共享区域



### 垃圾回收算法

**引用计数法**

对象被引用一次，在它的对象头上加一次引用次数，如果没有被引用（引用次数为 0），则此对象可回收。

缺点：无法解决循环引用。

**可达性算法**

以一系列叫做GC Root的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为「垃圾」,会被GC回收。

**标记清除算法**

先根据可达性算法标记出相应的可回收对象。对可回收的对象进行回收。

**复制算法**

把堆等分成两块区域A和B，区域A负责分配对象，区域B不分配, 对区域A使用以上所说的标记法把存活的对象标记出来，然后把区域A中存活的对象都复制到区域B（存活对象都依次紧邻排列）最后把A区对象全部清理掉释放出空间，这样就解决了内存碎片的问题了。

**标记整理法**

前面两步和标记清除法一样，不同的是它在标记清除法的基础上添加了一个整理的过程 ，即将所有的存活对象都往一端移动,紧邻排列，再清理掉另一端的所有区域，这样的话就解决了内存碎片的问题。但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。

**分代收集算法**

分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点，所以是现代虚拟机采用的首选算法,与其说它是算法，倒不是说它是一种策略，因为它是把上述几种算法整合在了一起。

